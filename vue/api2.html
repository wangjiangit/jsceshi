<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vue Api2</title>
</head>
<body>
<div id="example">
    div
</div>
</body>
<script type="text/javascript" src="./vue.js"></script>
<script type="text/javascript">

    //全局配置：
    // Vue.config.silent=true;   //取消 Vue 所有的日志与警告。
    // Vue.config.devtools=false;  //配置是否允许 vue-devtools 检查代码

    //指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。
    /*Vue.config.errorHandler = function (err, vm) {
        // handle error
    };*/


    //须使 Vue 忽略在 Vue 之外的自定义元素 (
   // Vue.config.ignoredElements=['my-custom-web-component', 'another-web-component'];

    //给 v-on 自定义键位别名。
   /* Vue.config.keyCodes = {
        v: 86,
        f1: 112,
        mediaPlayPause: 179,
        up: [38, 87]
    };*/


    //全局API
    //使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。
   /* var Profile=Vue.extend({
        "template":'<p>{{firstName}} {{lastName}} {{alias}}</p>',
        "data":function(){
            return {
                "firstName":"jian",
                "lastName":"wangjian",
                "alias":"Alice"
            };
        }
    });
    new Profile().$mount('#example');*/

    //Vue.nextTick  在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
    /*vm.msg = 'Hello'
    // DOM 还没有更新
    Vue.nextTick(function () {
        // DOM 更新了
    })*/

    //Vue.set(object,key,value);  //注意对象不能是Vue根实例
   // 设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。
   // Vue.set(vm.data,'c','c_value');

    //Vue.set(object,key);
    //删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。
    //Vue.delete(vm.data,'c');

    //Vue.directive()  //注册或获取全局指令

    //Vue.filter()  //注册或获取全局顾虑器

    /*
    // 注册
    Vue.filter('my-filter', function (value) {
        // 返回处理后的值
    });
    // getter，返回已注册的过滤器
    var myFilter = Vue.filter('my-filter');*/


    //Vue.component();      //注册或获取全局组件
    /*
    // 注册组件，传入一个扩展过的构造器
    Vue.component('my-component', Vue.extend({ /!* ... *!/ }))
    // 注册组件，传入一个选项对象（自动调用 Vue.extend）
    Vue.component('my-component', { /!* ... *!/ })
    // 获取注册的组件（始终返回构造器）
    var MyComponent = Vue.component('my-component')*/

    //Vue.use(plugin) // 插件相关

    //Vue.mixin  //全局注册一个混合

    //Vue.compile(template) //在render函数中编译模板字符串,只在独立构建时有效

   /* var res = Vue.compile('<div><span>{{ msg }}</span></div>')
    new Vue({
        data: {
            msg: 'hello'
        },
        render: res.render,
        staticRenderFns: res.staticRenderFns
    })*/

    //选项/数据
     //data  Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象(含有零个或多个的key/value对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。
     //实例创建之后，可以通过vm.$data访问原始数据对象，Vue实例也代理了data对象上的所有属性,因此等价
    // vm.$data.a 等价于 vm.a
    //以 _ 或 $ 开头的属性 不会 被 Vue 实例代理,你可以使用vm.$data._property 的方式访问这些属性。


    //props
    //props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。

    //propsData
    //创建实例时传递 props。主要作用是方便测试。


    //computed
    //计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。
   /*
    var vm = new Vue({
        data: { a: 1 },
        computed: {
            // 仅读取，值只须为函数
            aDouble: function () {
                return this.a * 2
            },
            // 读取和设置
            aPlus: {
                get: function () {
                    return this.a + 1
                },
                set: function (v) {
                    this.a = v - 1
                }
            }
        }
    })
    vm.aPlus   // -> 2
    vm.aPlus = 3
    vm.a       // -> 2
    vm.aDouble // -> 4
    */

    //methods  methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。
   /* var vm = new Vue({
        data: { a: 1 },
        methods: {
            plus: function () {
                this.a++
            }
        }
    })
    vm.plus()
    vm.a // 2*/



    var vm =new Vue({
        "el":"#example"
    });


    console.log(vm.$el);
</script>
</html>