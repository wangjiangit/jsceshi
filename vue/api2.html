<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vue Api2</title>
</head>
<body>
<div id="example" v-on:click="dianji">
    div{{message}}
    <span style="color:red" v-show="true"  v-text="msg"></span>
    <p v-html="p"></p>
    <span v-pre>{{ this will not be compiled }}</span>
</div>
<div id="div1">
    这是DIV1
</div>
</body>
<script type="text/javascript" src="./vue.js"></script>
<script type="text/javascript">

    //全局配置：
    // Vue.config.silent=true;   //取消 Vue 所有的日志与警告。
    // Vue.config.devtools=false;  //配置是否允许 vue-devtools 检查代码

    //指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。
    /*Vue.config.errorHandler = function (err, vm) {
        // handle error
    };*/


    //须使 Vue 忽略在 Vue 之外的自定义元素 (
   // Vue.config.ignoredElements=['my-custom-web-component', 'another-web-component'];

    //给 v-on 自定义键位别名。
   /* Vue.config.keyCodes = {
        v: 86,
        f1: 112,
        mediaPlayPause: 179,
        up: [38, 87]
    };*/


    //全局API
    //使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。
   /* var Profile=Vue.extend({
        "template":'<p>{{firstName}} {{lastName}} {{alias}}</p>',
        "data":function(){
            return {
                "firstName":"jian",
                "lastName":"wangjian",
                "alias":"Alice"
            };
        }
    });
    new Profile().$mount('#example');*/

    //Vue.nextTick  在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
    /*vm.msg = 'Hello'
    // DOM 还没有更新
    Vue.nextTick(function () {
        // DOM 更新了
    })*/

    //Vue.set(object,key,value);  //注意对象不能是Vue根实例
   // 设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。
   // Vue.set(vm.data,'c','c_value');

    //Vue.set(object,key);
    //删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。
    //Vue.delete(vm.data,'c');

    //Vue.directive()  //注册或获取全局指令

    //Vue.filter()  //注册或获取全局顾虑器

    /*
    // 注册
    Vue.filter('my-filter', function (value) {
        // 返回处理后的值
    });
    // getter，返回已注册的过滤器
    var myFilter = Vue.filter('my-filter');*/
    //可以这样用myFilter(value)

    //Vue.component();      //注册或获取全局组件
    /*
    // 注册组件，传入一个扩展过的构造器
    Vue.component('my-component', Vue.extend({ /!* ... *!/ }))
    // 注册组件，传入一个选项对象（自动调用 Vue.extend）
    Vue.component('my-component', { /!* ... *!/ })
    // 获取注册的组件（始终返回构造器）
    var MyComponent = Vue.component('my-component')*/

    //Vue.use(plugin) // 插件相关

    //Vue.mixin  //全局注册一个混合

    //Vue.compile(template) //在render函数中编译模板字符串,只在独立构建时有效

   /* var res = Vue.compile('<div><span>{{ msg }}</span></div>')
    new Vue({
        data: {
            msg: 'hello'
        },
        render: res.render,
        staticRenderFns: res.staticRenderFns
    })*/

    //选项/数据
     //data  Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象(含有零个或多个的key/value对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。
     //实例创建之后，可以通过vm.$data访问原始数据对象，Vue实例也代理了data对象上的所有属性,因此等价
    // vm.$data.a 等价于 vm.a
    //以 _ 或 $ 开头的属性 不会 被 Vue 实例代理,你可以使用vm.$data._property 的方式访问这些属性。


    //props
    //props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。

    //propsData
    //创建实例时传递 props。主要作用是方便测试。


    //computed
    //计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。
   /*
    var vm = new Vue({
        data: { a: 1 },
        computed: {
            // 仅读取，值只须为函数
            aDouble: function () {
                return this.a * 2
            },
            // 读取和设置
            aPlus: {
                get: function () {
                    return this.a + 1
                },
                set: function (v) {
                    this.a = v - 1
                }
            }
        }
    })
    vm.aPlus   // -> 2
    vm.aPlus = 3
    vm.a       // -> 2
    vm.aDouble // -> 4
    */

    //methods  methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。
   /* var vm = new Vue({
        data: { a: 1 },
        methods: {
            plus: function () {
                this.a++
            }
        }
    })
    vm.plus()
    vm.a // 2*/

    //watch
    //一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。

    /*var vm = new Vue({
        data: {
            a: 1,
            b: 2,
            c: 3
        },
        watch: {
            a: function (val, oldVal) {
                console.log('new: %s, old: %s', val, oldVal)
            },
            // 方法名
            b: 'someMethod',
            // 深度 watcher
            c: {
                handler: function (val, oldVal) { /!* ... *!/ },
                deep: true
            }
        }
    })
    vm.a = 2 // -> new: 2, old: 1*/


    //选项/DOM
    //el
    /*提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。
     在实例挂载之后， 元素可以用 vm.$el 访问。
     如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。
     */


    //template
    /*一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发 slot。

     如果值以 # 开始，则它用作选项符，将使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <script type="x-template"> 包含模板。
     */

    //render
    //字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。render 函数接收一个 createElement 方法作为第一个参数用来创建 VNode。


    //选项/生命周期钩子
    //所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。


    //beforeCreate
    //在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。

    //created
    //实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。

    //beforeMount
    //在挂载开始之前被调用：相关的 render 函数首次被调用。

    //mounted
    //el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。

    //beforeUpdate
    //数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。

    //updated
    //当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。

    //activated
    //keep-alive 组件激活时调用。

    //deactivated
    //keep-alive 组件停用时调用。

    //destroyed
    //Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

    //选项/资源

    //directives 包含Vue实例可用指令的哈希表
    //filters   包含Vue实例可用过滤器的哈希表
    //components 包含 Vue 实例可用组件的哈希表.

    //选项/杂项
    //parent
    //指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 $children 数组中

    //mixins
    //mixins 选项接受一个混合对象的数组。这些混合实例对象可以像正常的实例对象一样包含选项,他们将在 Vue.extend() 里最终选择使用相同的选项合并逻辑合并。举例：如果你混合包含一个钩子而创建组件本身也有一个,两个函数将被调用。
   // Mixin钩子按照传入顺序依次调用,并在调用组件自身的钩子之前被调用。

    //name
    //允许组件模板递归地调用自身。注意，组件在全局用 Vue.component() 注册时，全局 ID 自动作为组件的 name。
    //指定 name 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 vue-devtools, 未命名组件将显示成 <AnonymousComponent>, 这很没有语义。通过提供 name 选项，可以获得更有语义信息的组件树。


    //extend
    //允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数),而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。
    /*
    var CompA = { ... }
    // 在没有调用 Vue.extend 时候继承 CompA
    var CompB = {
        extends: CompA,
            ...
    }*/

    //delimiters
    //改变纯文本插入分隔符。
    /* new Vue({
        delimiters: ["{{", "}}"]
    });*/

    //functional
    //使组件无状态（没有 data ）和无实例（没有 this 上下文）。他们用一个简单的 render 函数返回虚拟节点使他们更容易渲染。


    //实例属性
    //Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问

    //vm.$data
    //Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问

    //vm.$el(只读)
    //Vue 实例使用的根 DOM 元素。

    //vm.options
    //用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处：
    // console.log(vm.$options.customOption1);

    //vm.$parent
    //父实例，如果当前实例有的话。

    //vm.$root
    //获取当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自已。

    //vm.$children
    //当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 $children 来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。

    //vm.$slots
    //用来访问被 slot 分发的内容。每个具名 slot 有其相应的属性（例如：slot="foo" 中的内容将会在 vm.$slots.foo 中被找到）。default 属性包括了所有没有被包含在具名 slot 中的节点。

    //vm.$refs
    //一个对象，其中包含了所有拥有 ref 注册的子组件。

    //vm.$isServer
    //当前 Vue 实例是否运行于服务器。


    //实例方法/数据

    //vm.$watch
    //观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。

    // 键路径

   /* vm.$watch('a.b.c', function (newVal, oldVal) {
        // 做点什么
    })
    // 函数
    vm.$watch(
            function () {
                return this.a + this.b
            },
            function (newVal, oldVal) {
                // 做点什么
            }
    )
    vm.$watch 返回一个取消观察函数，用来停止触发回调：

    var unwatch = vm.$watch('a', cb)
    // 之后取消观察
    unwatch()*/

    //vm.$set(object,key,value)
    //这是Vue.set()的别名

    //vm.$delete(object,key);
    //这是Vue.delete()的别名


    //实例方法/事件
    //vm.$on( event, callback )
    //监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。
    /*vm.$on('test', function (msg) {
        console.log(msg)
    })
    vm.$emit('test', 'hi')*/

    //vm.$once(event,callback);
    //监听一个自定义事件，但是只触发一次，在第一次触发之移除除监听器。

    //vm.$off(event,callback);
    //移除事件监听器。
    /*
    如果没有提供参数，则移除所有的事件监听器；

    如果只提供了事件，则移除该事件所有的监听器；

    如果同时提供了事件与回调，则只移除这个回调的监听器。*/

    //vm.$emit('event1',value1,value2,...);
    //触发当前实例上的事件。附加参数都会传给监听器回调


    //实例方法/生命周期
    //vm.$mount( [elementOrSelector] )
   /* 如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。

    如果没有提供 elementOrSelector 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生DOM API把它插入文档中。

    这个方法返回实例自身，因而可以链式调用其它实例方法。*/

    //vm.$forceUpdate()
    /*
    示例：迫使Vue实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。*/

    //vm.$nextTick(callback)
    //将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。

    //vm.$destroy
    //完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。
    //调用vm.$destroy()，将触发 beforeDestroy和destroyed 钩子

    //指令
    // v-text
    //更新元素的 textContent。如果要更新部分的 textContent ，需要使用 {{ Mustache }} 插值。

    //v-html
    //更新元素的 innerHTML 。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板,可以重新考虑通过是否通过使用组件来替代。

    //v-show
    //根据表达式之真假值，切换元素的 display CSS 属性。

    //v-if
    //根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <template> ，将提出它的内容作为条件块。

    //v-else
    //前一兄弟元素必须有 v-if 或 v-else-if。

    /*<div v-if="Math.random() > 0.5">
            Now you see me
    </div>
    <div v-else>
    Now you don't
    </div>*/

    //v-else-if
/*
    <div v-if="type === 'A'">
    A
    </div>
    <div v-else-if="type === 'B'">
    B
    </div>
    <div v-else-if="type === 'C'">
    C
    </div>
    <div v-else>
    Not A/B/C
    </div>*/

    //v-for
    //基于源数据多次渲染元素或模板块。
    //类型:Array | Object | number | string
    /*
    <div v-for="(item, index) in items"></div>
    <div v-for="(val, key) in object"></div>
    <div v-for="(val, key, index) in object"></div>
    <div v-for="item in items" :key="item.id">
            {{ item.text }}
    </div>*/

    //v-on
    //绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。

    //v-bind
    //动态地绑定一个或多个特性，或一个组件 prop 到表达式。
    /*
     修饰符：
     .prop - 被用于绑定 DOM 属性。(what’s the difference?)
     .camel - transform the kebab-case attribute name into camelCase. (supported since 2.1.0)

    在绑定 class 或 style 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。

    在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。

    没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。*/

    <!-- 绑定一个属性 -->
          /*  <img v-bind:src="imageSrc">
                <!-- 缩写 -->
            <img :src="imageSrc">
                <!-- with inline string concatenation -->
            <img :src="'/path/to/images/' + fileName">
                <!-- class 绑定 -->
            <div :class="{ red: isRed }"></div>
            <div :class="[classA, classB]"></div>
            <div :class="[classA, { classB: isB, classC: isC }]">
                <!-- style 绑定 -->
            <div :style="{ fontSize: size + 'px' }"></div>
            <div :style="[styleObjectA, styleObjectB]"></div>
                <!-- 绑定一个有属性的对象 -->
            <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>
                <!-- 通过 prop 修饰符绑定 DOM 属性 -->
            <div v-bind:text-content.prop="text"></div>
                <!-- prop 绑定. “prop” 必须在 my-component 中声明。 -->
            <my-component :prop="someThing"></my-component>
                <!-- XLink -->
            <svg><a :xlink:special="foo"></a></svg>*/

        //v-model
        //在表单控件或者组件上创建双向绑定。
        //随表单控件类型不同而不同。
        /*修饰符：

         .lazy - 取代 input 监听 change 事件
        .number - 输入字符串转为数字
        .trim - 输入首尾空格过滤*/

    //v-pre
    //跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译
    //<span v-pre>{{ this will not be compiled }}</span>

    //v-cloak
    //这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。

    //v-once
    //只渲染元素和组件一次。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。


    //特殊元素
    //key
    //key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。

    //ref
    //ref 被用来给元素或子组件注册引用信息。引用信息会根据父组件的 $refs 对象进行注册。如果在普通的DOM元素上使用，引用信息就是元素; 如果用在子组件上，引用信息就是组件实例:

    //slot
    //用于标记往哪个slot中插入子组件内容。

    //内置组件
    //component
    //渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染。

    //transition
    //<transition> 元素作为单个元素/组件的过渡效果。<transition> 不会渲染额外的 DOM 元素，也不会出现在检测过的组件层级中。它只是将内容包裹在其中，简单的运用过渡行为。

    //transition-group
    //<transition-group> 元素作为多个元素/组件的过渡效果。<transition-group> 渲染一个真实的 DOM 元素。默认渲染 <span>，可以通过 tag 属性配置哪个元素应该被渲染。

    //keep-alive
    //<keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。

    //slot
    //<slot> 元素作为组件模板之中的内容分发插槽。 <slot> 元素自身将被替换。

    var vm =new Vue({
        "el":"#example",
        "data":{
          "message":"message",
            "msg":"welcome to china",
            "p":"<span color='blue'>this paragraph</span>"
        },
        "computed":{
          "message1":function(){
                return this.message+'1';
          }
        },
        "methods":{
          "dianji":function(){
              this.message='hello world';
              console.log('dianji');
          }
        },
        "beforeCreate":function(){
           console.log('beforeCreate');
        },
        "created":function(){
            console.log('created');
        },
        "beforeMount":function(){
            console.log(this.$el);
            console.log('beforeMount');
        },
        "mounted":function(){
            console.log('mounted');
        },
        "beforeUpdate":function(){
            console.log('beforeUpdate');
        },
        "updated":function(){
            console.log('updated');
        },
        "destroyed":function(){
            console.log('destroyed');
        },
        "customOption1":'zidingyixuanxiang'
    });


   /* var vm1=new Vue({
        "template":"<h1>this is {{h1}}</h1>",
        "data":{
            "h1":'H1'
        }
    });
    vm1.$mount('#div1');*/
   // console.log(vm.$el);
   // console.log(vm.$options.customOption1);
   // console.log(vm.$root);
        

</script>
</html>